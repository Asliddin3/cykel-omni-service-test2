// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: locker/locker.proto

package locker

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type StationResponse struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID"`
	Longitude            float32  `protobuf:"fixed32,2,opt,name=Longitude,proto3" json:"Longitude"`
	Latitude             float32  `protobuf:"fixed32,3,opt,name=Latitude,proto3" json:"Latitude"`
	Name                 string   `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StationResponse) Reset()         { *m = StationResponse{} }
func (m *StationResponse) String() string { return proto.CompactTextString(m) }
func (*StationResponse) ProtoMessage()    {}
func (*StationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{0}
}
func (m *StationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StationResponse.Merge(m, src)
}
func (m *StationResponse) XXX_Size() int {
	return m.Size()
}
func (m *StationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StationResponse proto.InternalMessageInfo

func (m *StationResponse) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *StationResponse) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *StationResponse) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *StationResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type StationRequest struct {
	Longitude            float32  `protobuf:"fixed32,1,opt,name=Longitude,proto3" json:"Longitude"`
	Latitude             float32  `protobuf:"fixed32,2,opt,name=Latitude,proto3" json:"Latitude"`
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StationRequest) Reset()         { *m = StationRequest{} }
func (m *StationRequest) String() string { return proto.CompactTextString(m) }
func (*StationRequest) ProtoMessage()    {}
func (*StationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{1}
}
func (m *StationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StationRequest.Merge(m, src)
}
func (m *StationRequest) XXX_Size() int {
	return m.Size()
}
func (m *StationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StationRequest proto.InternalMessageInfo

func (m *StationRequest) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *StationRequest) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *StationRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type BikeCategoryRequest struct {
	ImagePath            string   `protobuf:"bytes,1,opt,name=ImagePath,proto3" json:"ImagePath"`
	BikeType             string   `protobuf:"bytes,2,opt,name=BikeType,proto3" json:"BikeType"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BikeCategoryRequest) Reset()         { *m = BikeCategoryRequest{} }
func (m *BikeCategoryRequest) String() string { return proto.CompactTextString(m) }
func (*BikeCategoryRequest) ProtoMessage()    {}
func (*BikeCategoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{2}
}
func (m *BikeCategoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BikeCategoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BikeCategoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BikeCategoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BikeCategoryRequest.Merge(m, src)
}
func (m *BikeCategoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *BikeCategoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BikeCategoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BikeCategoryRequest proto.InternalMessageInfo

func (m *BikeCategoryRequest) GetImagePath() string {
	if m != nil {
		return m.ImagePath
	}
	return ""
}

func (m *BikeCategoryRequest) GetBikeType() string {
	if m != nil {
		return m.BikeType
	}
	return ""
}

type BikeCategoryResponse struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID"`
	ImagePath            string   `protobuf:"bytes,2,opt,name=ImagePath,proto3" json:"ImagePath"`
	BikeType             string   `protobuf:"bytes,3,opt,name=BikeType,proto3" json:"BikeType"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BikeCategoryResponse) Reset()         { *m = BikeCategoryResponse{} }
func (m *BikeCategoryResponse) String() string { return proto.CompactTextString(m) }
func (*BikeCategoryResponse) ProtoMessage()    {}
func (*BikeCategoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{3}
}
func (m *BikeCategoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BikeCategoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BikeCategoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BikeCategoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BikeCategoryResponse.Merge(m, src)
}
func (m *BikeCategoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *BikeCategoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BikeCategoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BikeCategoryResponse proto.InternalMessageInfo

func (m *BikeCategoryResponse) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *BikeCategoryResponse) GetImagePath() string {
	if m != nil {
		return m.ImagePath
	}
	return ""
}

func (m *BikeCategoryResponse) GetBikeType() string {
	if m != nil {
		return m.BikeType
	}
	return ""
}

type BikeRequest struct {
	CategoryId           int64    `protobuf:"varint,1,opt,name=CategoryId,proto3" json:"CategoryId"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BikeRequest) Reset()         { *m = BikeRequest{} }
func (m *BikeRequest) String() string { return proto.CompactTextString(m) }
func (*BikeRequest) ProtoMessage()    {}
func (*BikeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{4}
}
func (m *BikeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BikeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BikeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BikeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BikeRequest.Merge(m, src)
}
func (m *BikeRequest) XXX_Size() int {
	return m.Size()
}
func (m *BikeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BikeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BikeRequest proto.InternalMessageInfo

func (m *BikeRequest) GetCategoryId() int64 {
	if m != nil {
		return m.CategoryId
	}
	return 0
}

func (m *BikeRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type BikeResponse struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID"`
	CategoryId           int64    `protobuf:"varint,2,opt,name=CategoryId,proto3" json:"CategoryId"`
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BikeResponse) Reset()         { *m = BikeResponse{} }
func (m *BikeResponse) String() string { return proto.CompactTextString(m) }
func (*BikeResponse) ProtoMessage()    {}
func (*BikeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{5}
}
func (m *BikeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BikeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BikeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BikeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BikeResponse.Merge(m, src)
}
func (m *BikeResponse) XXX_Size() int {
	return m.Size()
}
func (m *BikeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BikeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BikeResponse proto.InternalMessageInfo

func (m *BikeResponse) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *BikeResponse) GetCategoryId() int64 {
	if m != nil {
		return m.CategoryId
	}
	return 0
}

func (m *BikeResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type LockerInfoResponse struct {
	Voltage              float32  `protobuf:"fixed32,1,opt,name=Voltage,proto3" json:"Voltage"`
	Signal               int32    `protobuf:"varint,2,opt,name=Signal,proto3" json:"Signal"`
	GPSsate              int32    `protobuf:"varint,3,opt,name=GPSsate,proto3" json:"GPSsate"`
	IsLocked             bool     `protobuf:"varint,4,opt,name=IsLocked,proto3" json:"IsLocked"`
	Retention            int64    `protobuf:"varint,5,opt,name=Retention,proto3" json:"Retention"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockerInfoResponse) Reset()         { *m = LockerInfoResponse{} }
func (m *LockerInfoResponse) String() string { return proto.CompactTextString(m) }
func (*LockerInfoResponse) ProtoMessage()    {}
func (*LockerInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{6}
}
func (m *LockerInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockerInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockerInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockerInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockerInfoResponse.Merge(m, src)
}
func (m *LockerInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *LockerInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LockerInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LockerInfoResponse proto.InternalMessageInfo

func (m *LockerInfoResponse) GetVoltage() float32 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *LockerInfoResponse) GetSignal() int32 {
	if m != nil {
		return m.Signal
	}
	return 0
}

func (m *LockerInfoResponse) GetGPSsate() int32 {
	if m != nil {
		return m.GPSsate
	}
	return 0
}

func (m *LockerInfoResponse) GetIsLocked() bool {
	if m != nil {
		return m.IsLocked
	}
	return false
}

func (m *LockerInfoResponse) GetRetention() int64 {
	if m != nil {
		return m.Retention
	}
	return 0
}

type FirmwareInfoResponse struct {
	DeviceInfo           string   `protobuf:"bytes,1,opt,name=DeviceInfo,proto3" json:"DeviceInfo"`
	DeviceDate           string   `protobuf:"bytes,2,opt,name=DeviceDate,proto3" json:"DeviceDate"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirmwareInfoResponse) Reset()         { *m = FirmwareInfoResponse{} }
func (m *FirmwareInfoResponse) String() string { return proto.CompactTextString(m) }
func (*FirmwareInfoResponse) ProtoMessage()    {}
func (*FirmwareInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{7}
}
func (m *FirmwareInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirmwareInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirmwareInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirmwareInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirmwareInfoResponse.Merge(m, src)
}
func (m *FirmwareInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *FirmwareInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FirmwareInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FirmwareInfoResponse proto.InternalMessageInfo

func (m *FirmwareInfoResponse) GetDeviceInfo() string {
	if m != nil {
		return m.DeviceInfo
	}
	return ""
}

func (m *FirmwareInfoResponse) GetDeviceDate() string {
	if m != nil {
		return m.DeviceDate
	}
	return ""
}

type SimCardResponse struct {
	SIMCARD              int64    `protobuf:"varint,1,opt,name=SIMCARD,proto3" json:"SIMCARD"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimCardResponse) Reset()         { *m = SimCardResponse{} }
func (m *SimCardResponse) String() string { return proto.CompactTextString(m) }
func (*SimCardResponse) ProtoMessage()    {}
func (*SimCardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{8}
}
func (m *SimCardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimCardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimCardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimCardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimCardResponse.Merge(m, src)
}
func (m *SimCardResponse) XXX_Size() int {
	return m.Size()
}
func (m *SimCardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SimCardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SimCardResponse proto.InternalMessageInfo

func (m *SimCardResponse) GetSIMCARD() int64 {
	if m != nil {
		return m.SIMCARD
	}
	return 0
}

type LockerImei struct {
	IMEI                 int64    `protobuf:"varint,1,opt,name=IMEI,proto3" json:"IMEI"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockerImei) Reset()         { *m = LockerImei{} }
func (m *LockerImei) String() string { return proto.CompactTextString(m) }
func (*LockerImei) ProtoMessage()    {}
func (*LockerImei) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{9}
}
func (m *LockerImei) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockerImei) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockerImei.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockerImei) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockerImei.Merge(m, src)
}
func (m *LockerImei) XXX_Size() int {
	return m.Size()
}
func (m *LockerImei) XXX_DiscardUnknown() {
	xxx_messageInfo_LockerImei.DiscardUnknown(m)
}

var xxx_messageInfo_LockerImei proto.InternalMessageInfo

func (m *LockerImei) GetIMEI() int64 {
	if m != nil {
		return m.IMEI
	}
	return 0
}

type LocationIntervalResponse struct {
	SetInterval          int64    `protobuf:"varint,1,opt,name=SetInterval,proto3" json:"SetInterval"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocationIntervalResponse) Reset()         { *m = LocationIntervalResponse{} }
func (m *LocationIntervalResponse) String() string { return proto.CompactTextString(m) }
func (*LocationIntervalResponse) ProtoMessage()    {}
func (*LocationIntervalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{10}
}
func (m *LocationIntervalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationIntervalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationIntervalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationIntervalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationIntervalResponse.Merge(m, src)
}
func (m *LocationIntervalResponse) XXX_Size() int {
	return m.Size()
}
func (m *LocationIntervalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationIntervalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LocationIntervalResponse proto.InternalMessageInfo

func (m *LocationIntervalResponse) GetSetInterval() int64 {
	if m != nil {
		return m.SetInterval
	}
	return 0
}

type LocationIntervalRequest struct {
	IMEI                 int64    `protobuf:"varint,1,opt,name=IMEI,proto3" json:"IMEI"`
	IntervalInSecond     int64    `protobuf:"varint,2,opt,name=IntervalInSecond,proto3" json:"IntervalInSecond"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocationIntervalRequest) Reset()         { *m = LocationIntervalRequest{} }
func (m *LocationIntervalRequest) String() string { return proto.CompactTextString(m) }
func (*LocationIntervalRequest) ProtoMessage()    {}
func (*LocationIntervalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{11}
}
func (m *LocationIntervalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationIntervalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationIntervalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationIntervalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationIntervalRequest.Merge(m, src)
}
func (m *LocationIntervalRequest) XXX_Size() int {
	return m.Size()
}
func (m *LocationIntervalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationIntervalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LocationIntervalRequest proto.InternalMessageInfo

func (m *LocationIntervalRequest) GetIMEI() int64 {
	if m != nil {
		return m.IMEI
	}
	return 0
}

func (m *LocationIntervalRequest) GetIntervalInSecond() int64 {
	if m != nil {
		return m.IntervalInSecond
	}
	return 0
}

type LockerRequest struct {
	LockerIMEI           int64    `protobuf:"varint,1,opt,name=LockerIMEI,proto3" json:"LockerIMEI"`
	LockerMessage        string   `protobuf:"bytes,2,opt,name=LockerMessage,proto3" json:"LockerMessage"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockerRequest) Reset()         { *m = LockerRequest{} }
func (m *LockerRequest) String() string { return proto.CompactTextString(m) }
func (*LockerRequest) ProtoMessage()    {}
func (*LockerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{12}
}
func (m *LockerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockerRequest.Merge(m, src)
}
func (m *LockerRequest) XXX_Size() int {
	return m.Size()
}
func (m *LockerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LockerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LockerRequest proto.InternalMessageInfo

func (m *LockerRequest) GetLockerIMEI() int64 {
	if m != nil {
		return m.LockerIMEI
	}
	return 0
}

func (m *LockerRequest) GetLockerMessage() string {
	if m != nil {
		return m.LockerMessage
	}
	return ""
}

type AdminResponse struct {
	AdminMessage         string   `protobuf:"bytes,2,opt,name=AdminMessage,proto3" json:"AdminMessage"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdminResponse) Reset()         { *m = AdminResponse{} }
func (m *AdminResponse) String() string { return proto.CompactTextString(m) }
func (*AdminResponse) ProtoMessage()    {}
func (*AdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{13}
}
func (m *AdminResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminResponse.Merge(m, src)
}
func (m *AdminResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminResponse proto.InternalMessageInfo

func (m *AdminResponse) GetAdminMessage() string {
	if m != nil {
		return m.AdminMessage
	}
	return ""
}

type LocationRequest struct {
	IMEI                 int64    `protobuf:"varint,1,opt,name=IMEI,proto3" json:"IMEI"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocationRequest) Reset()         { *m = LocationRequest{} }
func (m *LocationRequest) String() string { return proto.CompactTextString(m) }
func (*LocationRequest) ProtoMessage()    {}
func (*LocationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{14}
}
func (m *LocationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationRequest.Merge(m, src)
}
func (m *LocationRequest) XXX_Size() int {
	return m.Size()
}
func (m *LocationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LocationRequest proto.InternalMessageInfo

func (m *LocationRequest) GetIMEI() int64 {
	if m != nil {
		return m.IMEI
	}
	return 0
}

type LocationResponse struct {
	IMEI                 int64    `protobuf:"varint,1,opt,name=IMEI,proto3" json:"IMEI"`
	IsTracking           bool     `protobuf:"varint,2,opt,name=IsTracking,proto3" json:"IsTracking"`
	UTCtime              string   `protobuf:"bytes,3,opt,name=UTCtime,proto3" json:"UTCtime"`
	IsValid              bool     `protobuf:"varint,4,opt,name=IsValid,proto3" json:"IsValid"`
	Latitude             float32  `protobuf:"fixed32,5,opt,name=Latitude,proto3" json:"Latitude"`
	IsNorth              bool     `protobuf:"varint,6,opt,name=IsNorth,proto3" json:"IsNorth"`
	Longitude            float32  `protobuf:"fixed32,7,opt,name=Longitude,proto3" json:"Longitude"`
	IsEast               bool     `protobuf:"varint,8,opt,name=IsEast,proto3" json:"IsEast"`
	CountSate            int32    `protobuf:"varint,9,opt,name=CountSate,proto3" json:"CountSate"`
	PositionAccuracy     float32  `protobuf:"fixed32,10,opt,name=PositionAccuracy,proto3" json:"PositionAccuracy"`
	UTCdate              string   `protobuf:"bytes,11,opt,name=UTCdate,proto3" json:"UTCdate"`
	Altitude             float32  `protobuf:"fixed32,12,opt,name=Altitude,proto3" json:"Altitude"`
	HeightUnit           string   `protobuf:"bytes,13,opt,name=HeightUnit,proto3" json:"HeightUnit"`
	ModeIndication       string   `protobuf:"bytes,14,opt,name=ModeIndication,proto3" json:"ModeIndication"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocationResponse) Reset()         { *m = LocationResponse{} }
func (m *LocationResponse) String() string { return proto.CompactTextString(m) }
func (*LocationResponse) ProtoMessage()    {}
func (*LocationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{15}
}
func (m *LocationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationResponse.Merge(m, src)
}
func (m *LocationResponse) XXX_Size() int {
	return m.Size()
}
func (m *LocationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LocationResponse proto.InternalMessageInfo

func (m *LocationResponse) GetIMEI() int64 {
	if m != nil {
		return m.IMEI
	}
	return 0
}

func (m *LocationResponse) GetIsTracking() bool {
	if m != nil {
		return m.IsTracking
	}
	return false
}

func (m *LocationResponse) GetUTCtime() string {
	if m != nil {
		return m.UTCtime
	}
	return ""
}

func (m *LocationResponse) GetIsValid() bool {
	if m != nil {
		return m.IsValid
	}
	return false
}

func (m *LocationResponse) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *LocationResponse) GetIsNorth() bool {
	if m != nil {
		return m.IsNorth
	}
	return false
}

func (m *LocationResponse) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *LocationResponse) GetIsEast() bool {
	if m != nil {
		return m.IsEast
	}
	return false
}

func (m *LocationResponse) GetCountSate() int32 {
	if m != nil {
		return m.CountSate
	}
	return 0
}

func (m *LocationResponse) GetPositionAccuracy() float32 {
	if m != nil {
		return m.PositionAccuracy
	}
	return 0
}

func (m *LocationResponse) GetUTCdate() string {
	if m != nil {
		return m.UTCdate
	}
	return ""
}

func (m *LocationResponse) GetAltitude() float32 {
	if m != nil {
		return m.Altitude
	}
	return 0
}

func (m *LocationResponse) GetHeightUnit() string {
	if m != nil {
		return m.HeightUnit
	}
	return ""
}

func (m *LocationResponse) GetModeIndication() string {
	if m != nil {
		return m.ModeIndication
	}
	return ""
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{16}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type UnlockResponse struct {
	UnlockResult         bool     `protobuf:"varint,1,opt,name=UnlockResult,proto3" json:"UnlockResult"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID"`
	UnlockedTime         int64    `protobuf:"varint,3,opt,name=UnlockedTime,proto3" json:"UnlockedTime"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockResponse) Reset()         { *m = UnlockResponse{} }
func (m *UnlockResponse) String() string { return proto.CompactTextString(m) }
func (*UnlockResponse) ProtoMessage()    {}
func (*UnlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{17}
}
func (m *UnlockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockResponse.Merge(m, src)
}
func (m *UnlockResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockResponse proto.InternalMessageInfo

func (m *UnlockResponse) GetUnlockResult() bool {
	if m != nil {
		return m.UnlockResult
	}
	return false
}

func (m *UnlockResponse) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UnlockResponse) GetUnlockedTime() int64 {
	if m != nil {
		return m.UnlockedTime
	}
	return 0
}

type UnlockRequest struct {
	IMEI                 int64    `protobuf:"varint,1,opt,name=IMEI,proto3" json:"IMEI"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID"`
	ResetTime            bool     `protobuf:"varint,3,opt,name=ResetTime,proto3" json:"ResetTime"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockRequest) Reset()         { *m = UnlockRequest{} }
func (m *UnlockRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockRequest) ProtoMessage()    {}
func (*UnlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c8ee7c4da0abb1, []int{18}
}
func (m *UnlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockRequest.Merge(m, src)
}
func (m *UnlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockRequest proto.InternalMessageInfo

func (m *UnlockRequest) GetIMEI() int64 {
	if m != nil {
		return m.IMEI
	}
	return 0
}

func (m *UnlockRequest) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UnlockRequest) GetResetTime() bool {
	if m != nil {
		return m.ResetTime
	}
	return false
}

func init() {
	proto.RegisterType((*StationResponse)(nil), "locker.StationResponse")
	proto.RegisterType((*StationRequest)(nil), "locker.StationRequest")
	proto.RegisterType((*BikeCategoryRequest)(nil), "locker.BikeCategoryRequest")
	proto.RegisterType((*BikeCategoryResponse)(nil), "locker.BikeCategoryResponse")
	proto.RegisterType((*BikeRequest)(nil), "locker.BikeRequest")
	proto.RegisterType((*BikeResponse)(nil), "locker.BikeResponse")
	proto.RegisterType((*LockerInfoResponse)(nil), "locker.LockerInfoResponse")
	proto.RegisterType((*FirmwareInfoResponse)(nil), "locker.FirmwareInfoResponse")
	proto.RegisterType((*SimCardResponse)(nil), "locker.SimCardResponse")
	proto.RegisterType((*LockerImei)(nil), "locker.LockerImei")
	proto.RegisterType((*LocationIntervalResponse)(nil), "locker.LocationIntervalResponse")
	proto.RegisterType((*LocationIntervalRequest)(nil), "locker.LocationIntervalRequest")
	proto.RegisterType((*LockerRequest)(nil), "locker.LockerRequest")
	proto.RegisterType((*AdminResponse)(nil), "locker.AdminResponse")
	proto.RegisterType((*LocationRequest)(nil), "locker.LocationRequest")
	proto.RegisterType((*LocationResponse)(nil), "locker.LocationResponse")
	proto.RegisterType((*Empty)(nil), "locker.Empty")
	proto.RegisterType((*UnlockResponse)(nil), "locker.UnlockResponse")
	proto.RegisterType((*UnlockRequest)(nil), "locker.UnlockRequest")
}

func init() { proto.RegisterFile("locker/locker.proto", fileDescriptor_33c8ee7c4da0abb1) }

var fileDescriptor_33c8ee7c4da0abb1 = []byte{
	// 988 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xc6, 0xce, 0x26, 0x4d, 0x4e, 0x9b, 0xb4, 0x4c, 0x4b, 0x6b, 0x65, 0x57, 0x21, 0xb2, 0x00,
	0x55, 0x20, 0x2d, 0x68, 0x7b, 0x81, 0x90, 0x58, 0x89, 0x6c, 0xd2, 0x2d, 0x96, 0xda, 0xdd, 0x6a,
	0xdc, 0x54, 0xda, 0x1b, 0xb4, 0x43, 0x3c, 0xa4, 0x56, 0x13, 0x4f, 0xb0, 0x27, 0x5b, 0xf5, 0x4d,
	0x10, 0x0f, 0x81, 0xc4, 0x5b, 0x70, 0xc9, 0x23, 0xa0, 0xf2, 0x22, 0x68, 0xc6, 0x33, 0xf6, 0x4c,
	0x12, 0x57, 0x5c, 0x25, 0xe7, 0x9b, 0x39, 0xdf, 0xf9, 0x3f, 0x1e, 0xd8, 0x9f, 0xb1, 0xc9, 0x2d,
	0x4d, 0xbf, 0xce, 0x7f, 0x9e, 0x2f, 0x52, 0xc6, 0x19, 0x6a, 0xe4, 0x92, 0xcf, 0x60, 0x37, 0xe4,
	0x84, 0xc7, 0x2c, 0xc1, 0x34, 0x5b, 0xb0, 0x24, 0xa3, 0xa8, 0x03, 0x6e, 0x30, 0xf2, 0x9c, 0xbe,
	0x73, 0x5c, 0xc3, 0x6e, 0x30, 0x42, 0xcf, 0xa0, 0x75, 0xce, 0x92, 0x69, 0xcc, 0x97, 0x11, 0xf5,
	0xdc, 0xbe, 0x73, 0xec, 0xe2, 0x12, 0x40, 0x5d, 0x68, 0x9e, 0x13, 0x9e, 0x1f, 0xd6, 0xe4, 0x61,
	0x21, 0x23, 0x04, 0x4f, 0xde, 0x90, 0x39, 0xf5, 0x9e, 0xf4, 0x9d, 0xe3, 0x16, 0x96, 0xff, 0xfd,
	0x9f, 0xa0, 0x53, 0x18, 0xfc, 0x75, 0x49, 0x33, 0x6e, 0xf3, 0x3b, 0x8f, 0xf1, 0xbb, 0x15, 0xfc,
	0x35, 0x83, 0xff, 0x2d, 0xec, 0xbf, 0x8a, 0x6f, 0xe9, 0x90, 0x70, 0x3a, 0x65, 0xe9, 0xbd, 0x61,
	0x24, 0x98, 0x93, 0x29, 0xbd, 0x24, 0xfc, 0x46, 0x1a, 0x69, 0xe1, 0x12, 0x10, 0x46, 0x84, 0xd2,
	0xd5, 0xfd, 0x22, 0x37, 0xd2, 0xc2, 0x85, 0xec, 0xbf, 0x87, 0x03, 0x9b, 0xb0, 0x3a, 0x4d, 0xa5,
	0x05, 0xf7, 0x31, 0x0b, 0xb5, 0x15, 0x0b, 0x03, 0xd8, 0x16, 0xff, 0xb5, 0xab, 0x3d, 0x00, 0x6d,
	0x2c, 0x88, 0x94, 0x01, 0x03, 0x29, 0xa2, 0x76, 0x8d, 0xa8, 0x31, 0xec, 0xe4, 0x14, 0x15, 0xce,
	0xd9, 0x9c, 0x6e, 0x25, 0xa7, 0x99, 0xc9, 0xdf, 0x1d, 0x40, 0xe7, 0xb2, 0x4b, 0x82, 0xe4, 0x17,
	0x56, 0x50, 0x7b, 0xb0, 0x75, 0xcd, 0x66, 0x9c, 0x4c, 0x75, 0xb1, 0xb4, 0x88, 0x0e, 0xa1, 0x11,
	0xc6, 0xd3, 0x84, 0xcc, 0xa4, 0x81, 0x3a, 0x56, 0x92, 0xd0, 0x38, 0xbb, 0x0c, 0x33, 0xc2, 0x73,
	0xfe, 0x3a, 0xd6, 0xa2, 0xc8, 0x4a, 0x90, 0x49, 0x1b, 0x91, 0x6c, 0x92, 0x26, 0x2e, 0x64, 0x91,
	0x4f, 0x4c, 0x39, 0x4d, 0x44, 0xab, 0x78, 0x75, 0xe9, 0x71, 0x09, 0xf8, 0xd7, 0x70, 0xf0, 0x3a,
	0x4e, 0xe7, 0x77, 0x24, 0xa5, 0x96, 0x77, 0x3d, 0x80, 0x11, 0xfd, 0x10, 0x4f, 0x24, 0xaa, 0x0a,
	0x6d, 0x20, 0xe5, 0xf9, 0x48, 0xb8, 0xe3, 0x9a, 0xe7, 0x02, 0xf1, 0xbf, 0x82, 0xdd, 0x30, 0x9e,
	0x0f, 0x49, 0x1a, 0x99, 0x01, 0x87, 0xc1, 0xc5, 0x70, 0x80, 0x75, 0x42, 0xb5, 0xe8, 0xf7, 0x01,
	0x54, 0x82, 0xe6, 0x34, 0x16, 0x39, 0x0c, 0x2e, 0x4e, 0x03, 0x75, 0x49, 0xfe, 0xf7, 0xbf, 0x07,
	0xef, 0x9c, 0x4d, 0x64, 0xbb, 0x07, 0x09, 0xa7, 0xe9, 0x07, 0x32, 0x2b, 0x78, 0xfb, 0xb0, 0x1d,
	0x52, 0xae, 0x61, 0xa5, 0x66, 0x42, 0xfe, 0x3b, 0x38, 0x5a, 0xd7, 0xce, 0x9b, 0x64, 0x83, 0x31,
	0xf4, 0x25, 0xec, 0xe9, 0x6b, 0x41, 0x12, 0xd2, 0x09, 0x4b, 0x74, 0xa9, 0xd7, 0x70, 0x7f, 0x0c,
	0xed, 0xdc, 0x75, 0xa3, 0xeb, 0x54, 0x2c, 0x25, 0xad, 0x81, 0xa0, 0xcf, 0xb4, 0xc2, 0x05, 0xcd,
	0x32, 0x51, 0xfc, 0x3c, 0x77, 0x36, 0xe8, 0x9f, 0x40, 0x7b, 0x10, 0xcd, 0xe3, 0x72, 0x99, 0xf8,
	0xb0, 0x23, 0x01, 0x5b, 0xcb, 0xc2, 0xfc, 0xcf, 0x61, 0x57, 0x87, 0xf9, 0x48, 0x78, 0xfe, 0x1f,
	0x35, 0xd8, 0x2b, 0xef, 0x29, 0xfe, 0x4d, 0x79, 0xe8, 0x01, 0x04, 0xd9, 0x55, 0x4a, 0x26, 0xb7,
	0x71, 0x32, 0x95, 0x16, 0x9b, 0xd8, 0x40, 0x44, 0x41, 0xc7, 0x57, 0x43, 0x1e, 0x17, 0xfd, 0xae,
	0x45, 0x71, 0x12, 0x64, 0xd7, 0x64, 0x16, 0xeb, 0x76, 0xd4, 0xa2, 0xb5, 0x86, 0xea, 0x2b, 0x6b,
	0x48, 0x6a, 0xbd, 0x61, 0x29, 0xbf, 0xf1, 0x1a, 0x5a, 0x4b, 0x8a, 0xf6, 0x6a, 0xdb, 0x5a, 0x5d,
	0x6d, 0x87, 0xd0, 0x08, 0xb2, 0x53, 0x92, 0x71, 0xaf, 0x29, 0xd5, 0x94, 0x24, 0xb4, 0x86, 0x6c,
	0x99, 0xf0, 0x50, 0xb4, 0x68, 0x4b, 0x4e, 0x4c, 0x09, 0x88, 0x2a, 0x5f, 0xb2, 0x2c, 0x16, 0x59,
	0x18, 0x4c, 0x26, 0xcb, 0x94, 0x4c, 0xee, 0x3d, 0x90, 0xd4, 0x6b, 0xb8, 0x8a, 0x34, 0x12, 0x3c,
	0xdb, 0x45, 0xa4, 0x91, 0x9a, 0xbc, 0xc1, 0x4c, 0xc5, 0xb3, 0x93, 0xc7, 0xa3, 0x65, 0x91, 0xbf,
	0x1f, 0x69, 0x3c, 0xbd, 0xe1, 0xe3, 0x24, 0xe6, 0x5e, 0x3b, 0x9f, 0x91, 0x12, 0x41, 0x5f, 0x40,
	0xe7, 0x82, 0x45, 0x34, 0x48, 0xa2, 0x38, 0xaf, 0x86, 0xd7, 0x91, 0x77, 0x56, 0x50, 0x7f, 0x0b,
	0xea, 0xa7, 0xf3, 0x05, 0xbf, 0xf7, 0x17, 0xd0, 0x19, 0x27, 0xe2, 0x83, 0x63, 0xb6, 0x45, 0x81,
	0x2c, 0x67, 0x5c, 0x96, 0xaf, 0x89, 0x2d, 0x4c, 0xa4, 0x67, 0x9c, 0xd1, 0x34, 0x18, 0xa9, 0x26,
	0x56, 0x52, 0xa9, 0x4b, 0xa3, 0x2b, 0x5d, 0xc3, 0x1a, 0xb6, 0x30, 0xff, 0x1d, 0xb4, 0x35, 0x57,
	0xf5, 0xbc, 0x54, 0x19, 0x90, 0x9b, 0x27, 0xa3, 0xbc, 0x60, 0x6f, 0xe2, 0x12, 0x78, 0xf1, 0x67,
	0x43, 0x4f, 0x42, 0x48, 0x53, 0xb1, 0x37, 0xd0, 0x50, 0xf6, 0xaf, 0x00, 0x78, 0x4a, 0xc9, 0x5c,
	0xb4, 0xd8, 0x27, 0xcf, 0xd5, 0xd7, 0xd6, 0x1a, 0xb2, 0x6e, 0x01, 0x5b, 0x43, 0x72, 0xec, 0x7c,
	0xe3, 0xa0, 0x97, 0x3a, 0xaa, 0x5c, 0xa3, 0x64, 0xb0, 0xe2, 0xe8, 0x1e, 0xae, 0xc2, 0x2a, 0xa1,
	0xef, 0xe1, 0x69, 0x48, 0xb9, 0x1e, 0x0f, 0xdd, 0xea, 0x7a, 0xec, 0xd1, 0xa7, 0x86, 0x3f, 0x9b,
	0xf6, 0x49, 0xb7, 0x5f, 0x7d, 0x41, 0x59, 0xf8, 0x0e, 0xe0, 0x8c, 0x72, 0xb5, 0x1c, 0x11, 0xb2,
	0x03, 0x14, 0x0b, 0xb0, 0x7b, 0xa4, 0xb1, 0xd5, 0x0d, 0xfa, 0x1a, 0x3e, 0x3e, 0x93, 0xce, 0xdd,
	0xd2, 0x54, 0xf3, 0xa3, 0xa3, 0x55, 0x8b, 0xda, 0x15, 0x6f, 0xfd, 0x40, 0xf1, 0x0c, 0x61, 0xf7,
	0x8c, 0x72, 0x73, 0xef, 0x6f, 0xf4, 0xe3, 0x99, 0xc6, 0x36, 0x7e, 0x21, 0x5e, 0xc2, 0xb6, 0x72,
	0xa6, 0x92, 0xa0, 0xbb, 0x82, 0x99, 0xea, 0x27, 0xd0, 0x09, 0x6f, 0x96, 0x7c, 0xc4, 0xee, 0x12,
	0x55, 0xa9, 0x4d, 0x0c, 0x6d, 0x8d, 0xc9, 0x01, 0x40, 0x2f, 0xa0, 0x8d, 0x69, 0xc6, 0x49, 0xca,
	0xff, 0xbf, 0xce, 0x5b, 0x40, 0xc3, 0x94, 0x12, 0x4e, 0xcd, 0xd7, 0x07, 0x7a, 0xaa, 0x2f, 0x6d,
	0x78, 0xe4, 0x94, 0x81, 0x6f, 0x7c, 0xb0, 0x7c, 0x0b, 0x50, 0x12, 0xa2, 0x7d, 0xf3, 0xae, 0x26,
	0x38, 0xb0, 0x41, 0xa5, 0xf8, 0x03, 0xb4, 0x73, 0x45, 0xf5, 0x70, 0x43, 0x45, 0x13, 0xda, 0x2f,
	0x39, 0xa3, 0x01, 0xec, 0x27, 0xe5, 0xab, 0xbd, 0xbf, 0x1e, 0x7a, 0xce, 0xdf, 0x0f, 0x3d, 0xe7,
	0x9f, 0x87, 0x9e, 0xf3, 0xdb, 0xbf, 0xbd, 0x8f, 0x7e, 0x6e, 0xc8, 0x67, 0xe8, 0xc9, 0x7f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x3e, 0x4d, 0x83, 0xdf, 0x9d, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LockerServiceClient is the client API for LockerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LockerServiceClient interface {
	// Locker Methods
	LockerStreaming(ctx context.Context, opts ...grpc.CallOption) (LockerService_LockerStreamingClient, error)
	UnlockLocker(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error)
	SetLocationTrackingInterval(ctx context.Context, in *LocationIntervalRequest, opts ...grpc.CallOption) (*LocationIntervalResponse, error)
	GetSimCard(ctx context.Context, in *LockerImei, opts ...grpc.CallOption) (*SimCardResponse, error)
	GetLockerLocation(ctx context.Context, in *LocationRequest, opts ...grpc.CallOption) (*LocationResponse, error)
	GetFirmwareInfo(ctx context.Context, in *LockerImei, opts ...grpc.CallOption) (*FirmwareInfoResponse, error)
	GetLockInfo(ctx context.Context, in *LockerImei, opts ...grpc.CallOption) (*LockerInfoResponse, error)
	ShutDownLocker(ctx context.Context, in *LockerImei, opts ...grpc.CallOption) (*Empty, error)
	RestartLocker(ctx context.Context, in *LockerImei, opts ...grpc.CallOption) (*Empty, error)
	//Bike Methods
	CreateBikeCategory(ctx context.Context, in *BikeCategoryRequest, opts ...grpc.CallOption) (*BikeCategoryResponse, error)
	CreateBike(ctx context.Context, in *BikeRequest, opts ...grpc.CallOption) (*BikeResponse, error)
	//Station Methods
	CreateStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationResponse, error)
}

type lockerServiceClient struct {
	cc *grpc.ClientConn
}

func NewLockerServiceClient(cc *grpc.ClientConn) LockerServiceClient {
	return &lockerServiceClient{cc}
}

func (c *lockerServiceClient) LockerStreaming(ctx context.Context, opts ...grpc.CallOption) (LockerService_LockerStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LockerService_serviceDesc.Streams[0], "/locker.LockerService/LockerStreaming", opts...)
	if err != nil {
		return nil, err
	}
	x := &lockerServiceLockerStreamingClient{stream}
	return x, nil
}

type LockerService_LockerStreamingClient interface {
	Send(*LockerRequest) error
	Recv() (*AdminResponse, error)
	grpc.ClientStream
}

type lockerServiceLockerStreamingClient struct {
	grpc.ClientStream
}

func (x *lockerServiceLockerStreamingClient) Send(m *LockerRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *lockerServiceLockerStreamingClient) Recv() (*AdminResponse, error) {
	m := new(AdminResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lockerServiceClient) UnlockLocker(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error) {
	out := new(UnlockResponse)
	err := c.cc.Invoke(ctx, "/locker.LockerService/UnlockLocker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockerServiceClient) SetLocationTrackingInterval(ctx context.Context, in *LocationIntervalRequest, opts ...grpc.CallOption) (*LocationIntervalResponse, error) {
	out := new(LocationIntervalResponse)
	err := c.cc.Invoke(ctx, "/locker.LockerService/SetLocationTrackingInterval", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockerServiceClient) GetSimCard(ctx context.Context, in *LockerImei, opts ...grpc.CallOption) (*SimCardResponse, error) {
	out := new(SimCardResponse)
	err := c.cc.Invoke(ctx, "/locker.LockerService/GetSimCard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockerServiceClient) GetLockerLocation(ctx context.Context, in *LocationRequest, opts ...grpc.CallOption) (*LocationResponse, error) {
	out := new(LocationResponse)
	err := c.cc.Invoke(ctx, "/locker.LockerService/GetLockerLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockerServiceClient) GetFirmwareInfo(ctx context.Context, in *LockerImei, opts ...grpc.CallOption) (*FirmwareInfoResponse, error) {
	out := new(FirmwareInfoResponse)
	err := c.cc.Invoke(ctx, "/locker.LockerService/GetFirmwareInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockerServiceClient) GetLockInfo(ctx context.Context, in *LockerImei, opts ...grpc.CallOption) (*LockerInfoResponse, error) {
	out := new(LockerInfoResponse)
	err := c.cc.Invoke(ctx, "/locker.LockerService/GetLockInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockerServiceClient) ShutDownLocker(ctx context.Context, in *LockerImei, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/locker.LockerService/ShutDownLocker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockerServiceClient) RestartLocker(ctx context.Context, in *LockerImei, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/locker.LockerService/RestartLocker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockerServiceClient) CreateBikeCategory(ctx context.Context, in *BikeCategoryRequest, opts ...grpc.CallOption) (*BikeCategoryResponse, error) {
	out := new(BikeCategoryResponse)
	err := c.cc.Invoke(ctx, "/locker.LockerService/CreateBikeCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockerServiceClient) CreateBike(ctx context.Context, in *BikeRequest, opts ...grpc.CallOption) (*BikeResponse, error) {
	out := new(BikeResponse)
	err := c.cc.Invoke(ctx, "/locker.LockerService/CreateBike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockerServiceClient) CreateStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationResponse, error) {
	out := new(StationResponse)
	err := c.cc.Invoke(ctx, "/locker.LockerService/CreateStation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LockerServiceServer is the server API for LockerService service.
type LockerServiceServer interface {
	// Locker Methods
	LockerStreaming(LockerService_LockerStreamingServer) error
	UnlockLocker(context.Context, *UnlockRequest) (*UnlockResponse, error)
	SetLocationTrackingInterval(context.Context, *LocationIntervalRequest) (*LocationIntervalResponse, error)
	GetSimCard(context.Context, *LockerImei) (*SimCardResponse, error)
	GetLockerLocation(context.Context, *LocationRequest) (*LocationResponse, error)
	GetFirmwareInfo(context.Context, *LockerImei) (*FirmwareInfoResponse, error)
	GetLockInfo(context.Context, *LockerImei) (*LockerInfoResponse, error)
	ShutDownLocker(context.Context, *LockerImei) (*Empty, error)
	RestartLocker(context.Context, *LockerImei) (*Empty, error)
	//Bike Methods
	CreateBikeCategory(context.Context, *BikeCategoryRequest) (*BikeCategoryResponse, error)
	CreateBike(context.Context, *BikeRequest) (*BikeResponse, error)
	//Station Methods
	CreateStation(context.Context, *StationRequest) (*StationResponse, error)
}

// UnimplementedLockerServiceServer can be embedded to have forward compatible implementations.
type UnimplementedLockerServiceServer struct {
}

func (*UnimplementedLockerServiceServer) LockerStreaming(srv LockerService_LockerStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method LockerStreaming not implemented")
}
func (*UnimplementedLockerServiceServer) UnlockLocker(ctx context.Context, req *UnlockRequest) (*UnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockLocker not implemented")
}
func (*UnimplementedLockerServiceServer) SetLocationTrackingInterval(ctx context.Context, req *LocationIntervalRequest) (*LocationIntervalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLocationTrackingInterval not implemented")
}
func (*UnimplementedLockerServiceServer) GetSimCard(ctx context.Context, req *LockerImei) (*SimCardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSimCard not implemented")
}
func (*UnimplementedLockerServiceServer) GetLockerLocation(ctx context.Context, req *LocationRequest) (*LocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLockerLocation not implemented")
}
func (*UnimplementedLockerServiceServer) GetFirmwareInfo(ctx context.Context, req *LockerImei) (*FirmwareInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFirmwareInfo not implemented")
}
func (*UnimplementedLockerServiceServer) GetLockInfo(ctx context.Context, req *LockerImei) (*LockerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLockInfo not implemented")
}
func (*UnimplementedLockerServiceServer) ShutDownLocker(ctx context.Context, req *LockerImei) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShutDownLocker not implemented")
}
func (*UnimplementedLockerServiceServer) RestartLocker(ctx context.Context, req *LockerImei) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestartLocker not implemented")
}
func (*UnimplementedLockerServiceServer) CreateBikeCategory(ctx context.Context, req *BikeCategoryRequest) (*BikeCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBikeCategory not implemented")
}
func (*UnimplementedLockerServiceServer) CreateBike(ctx context.Context, req *BikeRequest) (*BikeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBike not implemented")
}
func (*UnimplementedLockerServiceServer) CreateStation(ctx context.Context, req *StationRequest) (*StationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStation not implemented")
}

func RegisterLockerServiceServer(s *grpc.Server, srv LockerServiceServer) {
	s.RegisterService(&_LockerService_serviceDesc, srv)
}

func _LockerService_LockerStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LockerServiceServer).LockerStreaming(&lockerServiceLockerStreamingServer{stream})
}

type LockerService_LockerStreamingServer interface {
	Send(*AdminResponse) error
	Recv() (*LockerRequest, error)
	grpc.ServerStream
}

type lockerServiceLockerStreamingServer struct {
	grpc.ServerStream
}

func (x *lockerServiceLockerStreamingServer) Send(m *AdminResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *lockerServiceLockerStreamingServer) Recv() (*LockerRequest, error) {
	m := new(LockerRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _LockerService_UnlockLocker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).UnlockLocker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/UnlockLocker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).UnlockLocker(ctx, req.(*UnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LockerService_SetLocationTrackingInterval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocationIntervalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).SetLocationTrackingInterval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/SetLocationTrackingInterval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).SetLocationTrackingInterval(ctx, req.(*LocationIntervalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LockerService_GetSimCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockerImei)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).GetSimCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/GetSimCard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).GetSimCard(ctx, req.(*LockerImei))
	}
	return interceptor(ctx, in, info, handler)
}

func _LockerService_GetLockerLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).GetLockerLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/GetLockerLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).GetLockerLocation(ctx, req.(*LocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LockerService_GetFirmwareInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockerImei)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).GetFirmwareInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/GetFirmwareInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).GetFirmwareInfo(ctx, req.(*LockerImei))
	}
	return interceptor(ctx, in, info, handler)
}

func _LockerService_GetLockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockerImei)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).GetLockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/GetLockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).GetLockInfo(ctx, req.(*LockerImei))
	}
	return interceptor(ctx, in, info, handler)
}

func _LockerService_ShutDownLocker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockerImei)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).ShutDownLocker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/ShutDownLocker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).ShutDownLocker(ctx, req.(*LockerImei))
	}
	return interceptor(ctx, in, info, handler)
}

func _LockerService_RestartLocker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockerImei)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).RestartLocker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/RestartLocker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).RestartLocker(ctx, req.(*LockerImei))
	}
	return interceptor(ctx, in, info, handler)
}

func _LockerService_CreateBikeCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BikeCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).CreateBikeCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/CreateBikeCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).CreateBikeCategory(ctx, req.(*BikeCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LockerService_CreateBike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BikeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).CreateBike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/CreateBike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).CreateBike(ctx, req.(*BikeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LockerService_CreateStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockerServiceServer).CreateStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locker.LockerService/CreateStation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockerServiceServer).CreateStation(ctx, req.(*StationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LockerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "locker.LockerService",
	HandlerType: (*LockerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UnlockLocker",
			Handler:    _LockerService_UnlockLocker_Handler,
		},
		{
			MethodName: "SetLocationTrackingInterval",
			Handler:    _LockerService_SetLocationTrackingInterval_Handler,
		},
		{
			MethodName: "GetSimCard",
			Handler:    _LockerService_GetSimCard_Handler,
		},
		{
			MethodName: "GetLockerLocation",
			Handler:    _LockerService_GetLockerLocation_Handler,
		},
		{
			MethodName: "GetFirmwareInfo",
			Handler:    _LockerService_GetFirmwareInfo_Handler,
		},
		{
			MethodName: "GetLockInfo",
			Handler:    _LockerService_GetLockInfo_Handler,
		},
		{
			MethodName: "ShutDownLocker",
			Handler:    _LockerService_ShutDownLocker_Handler,
		},
		{
			MethodName: "RestartLocker",
			Handler:    _LockerService_RestartLocker_Handler,
		},
		{
			MethodName: "CreateBikeCategory",
			Handler:    _LockerService_CreateBikeCategory_Handler,
		},
		{
			MethodName: "CreateBike",
			Handler:    _LockerService_CreateBike_Handler,
		},
		{
			MethodName: "CreateStation",
			Handler:    _LockerService_CreateStation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LockerStreaming",
			Handler:       _LockerService_LockerStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "locker/locker.proto",
}

func (m *StationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Latitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Longitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i--
		dAtA[i] = 0x15
	}
	if m.ID != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Latitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i--
		dAtA[i] = 0x15
	}
	if m.Longitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *BikeCategoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BikeCategoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BikeCategoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BikeType) > 0 {
		i -= len(m.BikeType)
		copy(dAtA[i:], m.BikeType)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.BikeType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ImagePath) > 0 {
		i -= len(m.ImagePath)
		copy(dAtA[i:], m.ImagePath)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.ImagePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BikeCategoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BikeCategoryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BikeCategoryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BikeType) > 0 {
		i -= len(m.BikeType)
		copy(dAtA[i:], m.BikeType)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.BikeType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ImagePath) > 0 {
		i -= len(m.ImagePath)
		copy(dAtA[i:], m.ImagePath)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.ImagePath)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BikeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BikeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BikeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.CategoryId != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.CategoryId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BikeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BikeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BikeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CategoryId != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.CategoryId))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockerInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockerInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockerInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Retention != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.Retention))
		i--
		dAtA[i] = 0x28
	}
	if m.IsLocked {
		i--
		if m.IsLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.GPSsate != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.GPSsate))
		i--
		dAtA[i] = 0x18
	}
	if m.Signal != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.Signal))
		i--
		dAtA[i] = 0x10
	}
	if m.Voltage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Voltage))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *FirmwareInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirmwareInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirmwareInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeviceDate) > 0 {
		i -= len(m.DeviceDate)
		copy(dAtA[i:], m.DeviceDate)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.DeviceDate)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeviceInfo) > 0 {
		i -= len(m.DeviceInfo)
		copy(dAtA[i:], m.DeviceInfo)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.DeviceInfo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimCardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimCardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SIMCARD != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.SIMCARD))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockerImei) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockerImei) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockerImei) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IMEI != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.IMEI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LocationIntervalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationIntervalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationIntervalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SetInterval != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.SetInterval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LocationIntervalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationIntervalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationIntervalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IntervalInSecond != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.IntervalInSecond))
		i--
		dAtA[i] = 0x10
	}
	if m.IMEI != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.IMEI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LockerMessage) > 0 {
		i -= len(m.LockerMessage)
		copy(dAtA[i:], m.LockerMessage)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.LockerMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.LockerIMEI != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.LockerIMEI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AdminResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AdminMessage) > 0 {
		i -= len(m.AdminMessage)
		copy(dAtA[i:], m.AdminMessage)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.AdminMessage)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *LocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IMEI != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.IMEI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LocationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ModeIndication) > 0 {
		i -= len(m.ModeIndication)
		copy(dAtA[i:], m.ModeIndication)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.ModeIndication)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.HeightUnit) > 0 {
		i -= len(m.HeightUnit)
		copy(dAtA[i:], m.HeightUnit)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.HeightUnit)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Altitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Altitude))))
		i--
		dAtA[i] = 0x65
	}
	if len(m.UTCdate) > 0 {
		i -= len(m.UTCdate)
		copy(dAtA[i:], m.UTCdate)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.UTCdate)))
		i--
		dAtA[i] = 0x5a
	}
	if m.PositionAccuracy != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PositionAccuracy))))
		i--
		dAtA[i] = 0x55
	}
	if m.CountSate != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.CountSate))
		i--
		dAtA[i] = 0x48
	}
	if m.IsEast {
		i--
		if m.IsEast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Longitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i--
		dAtA[i] = 0x3d
	}
	if m.IsNorth {
		i--
		if m.IsNorth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Latitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i--
		dAtA[i] = 0x2d
	}
	if m.IsValid {
		i--
		if m.IsValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.UTCtime) > 0 {
		i -= len(m.UTCtime)
		copy(dAtA[i:], m.UTCtime)
		i = encodeVarintLocker(dAtA, i, uint64(len(m.UTCtime)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsTracking {
		i--
		if m.IsTracking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IMEI != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.IMEI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UnlockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UnlockedTime != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.UnlockedTime))
		i--
		dAtA[i] = 0x18
	}
	if m.UserID != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.UnlockResult {
		i--
		if m.UnlockResult {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResetTime {
		i--
		if m.ResetTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UserID != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.IMEI != 0 {
		i = encodeVarintLocker(dAtA, i, uint64(m.IMEI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintLocker(dAtA []byte, offset int, v uint64) int {
	offset -= sovLocker(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovLocker(uint64(m.ID))
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.Latitude != 0 {
		n += 5
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Longitude != 0 {
		n += 5
	}
	if m.Latitude != 0 {
		n += 5
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BikeCategoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImagePath)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	l = len(m.BikeType)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BikeCategoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovLocker(uint64(m.ID))
	}
	l = len(m.ImagePath)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	l = len(m.BikeType)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BikeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CategoryId != 0 {
		n += 1 + sovLocker(uint64(m.CategoryId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BikeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovLocker(uint64(m.ID))
	}
	if m.CategoryId != 0 {
		n += 1 + sovLocker(uint64(m.CategoryId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockerInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voltage != 0 {
		n += 5
	}
	if m.Signal != 0 {
		n += 1 + sovLocker(uint64(m.Signal))
	}
	if m.GPSsate != 0 {
		n += 1 + sovLocker(uint64(m.GPSsate))
	}
	if m.IsLocked {
		n += 2
	}
	if m.Retention != 0 {
		n += 1 + sovLocker(uint64(m.Retention))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirmwareInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceInfo)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	l = len(m.DeviceDate)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimCardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SIMCARD != 0 {
		n += 1 + sovLocker(uint64(m.SIMCARD))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockerImei) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IMEI != 0 {
		n += 1 + sovLocker(uint64(m.IMEI))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationIntervalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetInterval != 0 {
		n += 1 + sovLocker(uint64(m.SetInterval))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationIntervalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IMEI != 0 {
		n += 1 + sovLocker(uint64(m.IMEI))
	}
	if m.IntervalInSecond != 0 {
		n += 1 + sovLocker(uint64(m.IntervalInSecond))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LockerIMEI != 0 {
		n += 1 + sovLocker(uint64(m.LockerIMEI))
	}
	l = len(m.LockerMessage)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdminResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AdminMessage)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IMEI != 0 {
		n += 1 + sovLocker(uint64(m.IMEI))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IMEI != 0 {
		n += 1 + sovLocker(uint64(m.IMEI))
	}
	if m.IsTracking {
		n += 2
	}
	l = len(m.UTCtime)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.IsValid {
		n += 2
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.IsNorth {
		n += 2
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.IsEast {
		n += 2
	}
	if m.CountSate != 0 {
		n += 1 + sovLocker(uint64(m.CountSate))
	}
	if m.PositionAccuracy != 0 {
		n += 5
	}
	l = len(m.UTCdate)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.Altitude != 0 {
		n += 5
	}
	l = len(m.HeightUnit)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	l = len(m.ModeIndication)
	if l > 0 {
		n += 1 + l + sovLocker(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnlockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnlockResult {
		n += 2
	}
	if m.UserID != 0 {
		n += 1 + sovLocker(uint64(m.UserID))
	}
	if m.UnlockedTime != 0 {
		n += 1 + sovLocker(uint64(m.UnlockedTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IMEI != 0 {
		n += 1 + sovLocker(uint64(m.IMEI))
	}
	if m.UserID != 0 {
		n += 1 + sovLocker(uint64(m.UserID))
	}
	if m.ResetTime {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLocker(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLocker(x uint64) (n int) {
	return sovLocker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BikeCategoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BikeCategoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BikeCategoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BikeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BikeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BikeCategoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BikeCategoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BikeCategoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BikeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BikeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BikeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BikeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BikeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			m.CategoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CategoryId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BikeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BikeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BikeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			m.CategoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CategoryId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockerInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockerInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockerInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Voltage = float32(math.Float32frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signal", wireType)
			}
			m.Signal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Signal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GPSsate", wireType)
			}
			m.GPSsate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GPSsate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocked = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			m.Retention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retention |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirmwareInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirmwareInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirmwareInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimCardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimCardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SIMCARD", wireType)
			}
			m.SIMCARD = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SIMCARD |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockerImei) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockerImei: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockerImei: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IMEI", wireType)
			}
			m.IMEI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IMEI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationIntervalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationIntervalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationIntervalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetInterval", wireType)
			}
			m.SetInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationIntervalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationIntervalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationIntervalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IMEI", wireType)
			}
			m.IMEI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IMEI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalInSecond", wireType)
			}
			m.IntervalInSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalInSecond |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockerIMEI", wireType)
			}
			m.LockerIMEI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockerIMEI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockerMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockerMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IMEI", wireType)
			}
			m.IMEI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IMEI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IMEI", wireType)
			}
			m.IMEI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IMEI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTracking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTracking = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UTCtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UTCtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsValid = bool(v != 0)
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNorth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNorth = bool(v != 0)
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEast = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountSate", wireType)
			}
			m.CountSate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountSate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionAccuracy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PositionAccuracy = float32(math.Float32frombits(v))
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UTCdate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UTCdate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Altitude = float32(math.Float32frombits(v))
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeightUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeIndication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModeIndication = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockResult", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnlockResult = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockedTime", wireType)
			}
			m.UnlockedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockedTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IMEI", wireType)
			}
			m.IMEI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IMEI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResetTime = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLocker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLocker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLocker
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLocker
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLocker
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLocker        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLocker          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLocker = fmt.Errorf("proto: unexpected end of group")
)
